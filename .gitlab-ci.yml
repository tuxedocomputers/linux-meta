default:
    # Custom docker image: ubuntu:jammy with some stuff preinstalled, see before_script comment.
    image: linux-builder-jammy

    before_script:
        # This is already installed on linux-meta-builder-ubuntu-jammy docker image, but manual
        # installation required on runners that only have ubuntu:jammy available.
        # - apt-get update
        # - DEBIAN_FRONTEND=noninteractive apt-get install -y git dpkg-dev devscripts debhelper gawk kmod

        # Configure git to be able to push.
        - git config --global user.name "Tuxedo BOT"
        - git config --global user.email "tux@tuxedocomputers.com"
        - gpg --import $TUXEDO_BOT_GPG_PRIVATE_KEY

        # Setup author for dch.
        - export DEBFULLNAME="Tuxedo BOT"
        - export DEBEMAIL="tux@tuxedocomputers.com"

        # Set token based checkout url for the internal gitlab repository, this and the public github repository are 1 to 1 mirrors on all branches used here.
        - export LINUX_REPO_URL="https://${TUXEDO_BOT_GITLAB_USERNAME}:${TUXEDO_BOT_GITLAB_CI_PERSONAL_ACCESS_TOKEN}@${LINUX_REPO_CLONE_URL_HTTPS#https://}"

variables:
    # Create a fresh clone every time, instead of caching the last checkout of the repository. This
    # is required for a clean slate the way the auto-update script expects.
    GIT_STRATEGY: clone

stages:
    # The update job is not run on the same commit as the build, and deploy jobs. It's included in this
    # explicit order here purely to make the CI script more readable.
    - update
    - build
    - deploy

update:
    stage: update

    only:
        # Don't run on every push, but only manually issued and periodically.
        - web
        - schedule
        - trigger

    script:
        # GitLab CI checks out in a detached head state, correct this to be able to push.
        - git checkout $CI_COMMIT_BRANCH

        # Run the logic determining the new version, update, and push the result.
        - ./auto-update

        # Push using a GitLab Personal Access Token.
        - git push "https://${TUXEDO_BOT_GITLAB_USERNAME}:${TUXEDO_BOT_GITLAB_CI_PERSONAL_ACCESS_TOKEN}@${CI_REPOSITORY_URL#*@}" $CI_COMMIT_BRANCH
        - git push "https://${TUXEDO_BOT_GITLAB_USERNAME}:${TUXEDO_BOT_GITLAB_CI_PERSONAL_ACCESS_TOKEN}@${CI_REPOSITORY_URL#*@}" $(git describe --tags --abbrev=0)

build:
    stage: build

    only:
        # Build after new tag has been pushed.
        - tags

    script:
        # Setup environment and create packages.
        - ./build

        # Copy results into build directory so that the artifacts keyword can pick them up.
        - mkdir -p output
        - mv ../*.build ../*.buildinfo ../*.changes ../*.deb ../*.dsc ../*.tar.xz output

    artifacts:
        # Save build results.
        paths:
            - output

deploy:
    stage: deploy

    only:
        # Build after new tag has been pushed.
        - tags

    variables:
        # This job does not need a clean working directory.
        GIT_STRATEGY: fetch

        # Defines subfolder for flat apt testing repo
        UBUNTU_CODENAME: jammy

    script:
        # create new key and cert based on ca
        - curl -s https://gitlab.com/gitlab-org/incubation-engineering/mobile-devops/download-secure-files/-/raw/main/installer | bash
        - openssl genrsa -out .secure_files/ci_job.key 4096
        - openssl req -new -key .secure_files/ci_job.key -out .secure_files/ci_job.csr -subj "/CN=deb"
        - openssl x509 -req -days 1 -in .secure_files/ci_job.csr -CA .secure_files/static.ca.deb.crt -CAkey .secure_files/static.ca.deb.key -set_serial 01 -out .secure_files/ci_job.crt

        # Get version number.
        - CURRENT_VERSION=$(grep -Pom1 '(?<=^linux-meta-tuxedo-22.04 \().*(?=\))' debian/changelog)

        # Upload to new folder on internal Nextcould.
        - curl -X MKCOL $TUXEDO_BOT_WEBDAV_LINUX_META_22_04_BASE_FOLDER_URL/$CURRENT_VERSION --user $TUXEDO_BOT_NEXTCLOUD_USERNAME:$TUXEDO_BOT_NEXTCLOUD_PASSWORD
        - find output/* -exec curl -T '{}' $TUXEDO_BOT_WEBDAV_LINUX_META_22_04_BASE_FOLDER_URL/$CURRENT_VERSION/ --user $TUXEDO_BOT_NEXTCLOUD_USERNAME:$TUXEDO_BOT_NEXTCLOUD_PASSWORD \;

        # Upload to flat apt testing repo
        - WEBDAV_DIR_URL="https://deb.static.tuxedocomputers.com/linux"
        - WEBDAV_DIR_URL_HTTP="http://static.tuxedocomputers.com/deb/linux"

        - |
            http_status=$(curl -i --cert .secure_files/ci_job.crt --key .secure_files/ci_job.key -w "%{http_code}" -o /dev/null $WEBDAV_DIR_URL/)
            if [[ ! "$http_status" =~ ^2[0-9][0-9]$ ]]; then
                curl -i --cert .secure_files/ci_job.crt --key .secure_files/ci_job.key $WEBDAV_DIR_URL
                exit 1
            fi

        - |
            http_status=$(curl -i --cert .secure_files/ci_job.crt --key .secure_files/ci_job.key -w "%{http_code}" -o /dev/null $WEBDAV_DIR_URL/$UBUNTU_CODENAME/)
            if [[ ! "$http_status" =~ ^2[0-9][0-9]$ ]]; then
                curl -i --cert .secure_files/ci_job.crt --key .secure_files/ci_job.key $WEBDAV_DIR_URL
                exit 1
            fi

        - |
            http_status=$(curl -i --cert .secure_files/ci_job.crt --key .secure_files/ci_job.key -w "%{http_code}" -o /dev/null $WEBDAV_DIR_URL/$UBUNTU_CODENAME/$CURRENT_VERSION/)
            if [[ ! "$http_status" =~ ^2[0-9][0-9]$ ]]; then
                curl -i --cert .secure_files/ci_job.crt --key .secure_files/ci_job.key $WEBDAV_DIR_URL
                exit 1
            fi

        - cd output
        - dpkg-scanpackages . /dev/null | xz -9 > Packages.xz

        - |
            for file in Packages.xz *.deb; do
                response=$(curl -T "$file" --cert .secure_files/ci_job.crt --key .secure_files/ci_job.key -X PUT -w "%{http_code}" -o /dev/null -s $WEBDAV_DIR_URL/$UBUNTU_CODENAME/$CURRENT_VERSION/"$file"_tmp)

                if [[ ! "$http_status" =~ ^2[0-9][0-9]$ ]]; then
                echo "Failed to upload $file. HTTP status: $response"
                exit 1
                else
                echo "Successfully uploaded $file"
                fi
            done

        - |
            for file in Packages.xz *.deb; do
                response_mv=$(curl --cert .secure_files/ci_job.crt --key .secure_files/ci_job.key -X MOVE -w "%{http_code}" -o /dev/null -s --header "Destination: $WEBDAV_DIR_URL_HTTP/$UBUNTU_CODENAME/$CURRENT_VERSION/$file" --header "Overwrite: T" "$WEBDAV_DIR_URL/$UBUNTU_CODENAME/$CURRENT_VERSION/$file"_tmp)

                if [[ ! "$http_status" =~ ^2[0-9][0-9]$ ]]; then
                echo "Failed to copy $file. HTTP status: $response_mv"
                exit 1
                else
                echo "Successfully copied $file"
                fi
            done
